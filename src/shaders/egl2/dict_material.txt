<NML = 1.0>

<Base =
	// The engine automatically declares skinning related inputs.
	<Input =
		<Attribute=<Name="a_position"><Semantic="Position">>
		<Uniform=<Name="u_mvp_matrix"><Semantic="ModelViewProjectionMatrix"><Scope=<Vertex>>>
	>
	<Varying =
		<Variable=<Name="v_skin_mtx"><Type="mat4">>
	>
	<Vertex = "
//-----------------------------------------------------------------------------
#ifdef	_SKINNED
	v_skin_mtx = bone_mtx[int(bone_idx.x)] * bone_w.x + bone_mtx[int(bone_idx.y)] * bone_w.y + bone_mtx[int(bone_idx.z)] * bone_w.z + bone_mtx[int(bone_idx.w)] * bone_w.w;
	float4	v_f_position = v_skin_mtx * float4(a_position, 1.0);
#else
	float4	v_f_position = float4(a_position, 1.0);
#endif
//-----------------------------------------------------------------------------
	">
	<Fragment = "
//-----------------------------------------------------------------------------
#ifdef	_SKINNED
	float3	v_f_normal = normalize(mat3(v_skin_mtx) * %in.normal%);
#else
	float3	v_f_normal = %in.normal%;
#endif
//-----------------------------------------------------------------------------
	">
>

<Velocity =
	// The engine automatically declares skinning related inputs.
	<Input =
		<Attribute=<Name="a_position"><Semantic="Position">>
		<Uniform=<Name="u_previous_mvp_matrix"><Semantic="PreviousModelViewProjectionMatrix"><Scope=<Vertex>>>

		<Attribute=<Name="a_normal"><Semantic="Normal">>

		<Uniform=<Name="u_mv_matrix"><Semantic="ModelViewMatrix"><Scope=<Vertex>>>
		<Uniform=<Name="u_previous_mv_matrix"><Semantic="PreviousModelViewMatrix"><Scope=<Vertex>>>
		<Uniform=<Name="u_p_matrix"><Semantic="ProjectionMatrix"><Scope=<Vertex>>>
	>
	<Varying =
		<Variable=<Name="v_ppos"><Type="float4">>
		<Variable=<Name="v_previous_ppos"><Type="float4">>
	>
	<Vertex = "
//-----------------------------------------------------------------------------
#ifdef	_SKINNED
	mat4	previous_skin_mtx = previous_bone_mtx[int(bone_idx.x)] * bone_w.x + previous_bone_mtx[int(bone_idx.y)] * bone_w.y + previous_bone_mtx[int(bone_idx.z)] * bone_w.z + previous_bone_mtx[int(bone_idx.w)] * bone_w.w;
	float4	f_previous_position = previous_skin_mtx * float4(a_position, 1.0);
#else
	float4	f_previous_position = v_f_position;
#endif

	// Projected vertice.
	v_ppos = u_mvp_matrix * v_f_position;
	v_previous_ppos = u_previous_mvp_matrix * f_previous_position;

	/*
		Volume expansion along the motion vector.
		Extrusions are slightly overshot to minimize trail clipping.
	*/
#if		1
#ifdef	_SKINNED
	float3	mv_normal = normalize(mat3(v_skin_mtx) * a_normal);
#else
	float3	mv_normal = normalize(mat3(u_mv_matrix) * a_normal);
#endif
	float4	vpos = u_mv_matrix * v_f_position;
	float4	previous_vpos = u_previous_mv_matrix * f_previous_position;

	float4	dt_vpos = vpos - previous_vpos;
	vpos += dt_vpos * dot(mv_normal, normalize(dt_vpos.xyz)) * 1.1;		// Slightly overshot.

	%out.position% = u_p_matrix * vpos;
#else
	%out.position% = u_mvp_matrix * v_f_position;
#endif
//-----------------------------------------------------------------------------
	">
	<Fragment = "
//-----------------------------------------------------------------------------
	float2	V = (v_previous_ppos.xy / v_previous_ppos.w) - (v_ppos.xy / v_ppos.w);
//	%out.color% = float4(%in.diffuse%.xyz, 1.0);
	%out.color% = float4(V, 0.0, 1.0);
//-----------------------------------------------------------------------------
	">
>

<Depth =
	<Vertex = "
//-----------------------------------------------------------------------------
%out.position% = u_mvp_matrix * v_f_position;
//-----------------------------------------------------------------------------
	">
	<Fragment = "
//-----------------------------------------------------------------------------
// ATI requires color to be written for depth only.
%out.color% = vec4(%in.fragcoord%.zzz, %in.opacity%);
// nVidia requires depth to be written for depth only.
%out.depth% = %out.color%.z;
//-----------------------------------------------------------------------------
	">
>

<NormalDepth =
	<Input =
		<Uniform=<Name="u_mv_matrix"><Semantic="ModelViewMatrix"><Scope=<Vertex>>>
		<Uniform=<Name="u_nmv_matrix"><Semantic="NormalViewMatrix"><Scope=<Fragment>>>
	>
	<Varying =
		<Variable=<Name="v_depth"><Type="float">>
	>
	<Vertex = "
//-----------------------------------------------------------------------------
v_depth = (u_mv_matrix * v_f_position).z;
%out.position% = u_mvp_matrix * v_f_position;
//-----------------------------------------------------------------------------
	">
	<Fragment = "
//-----------------------------------------------------------------------------
float3	v_normal_view = u_nmv_matrix * v_f_normal;
%out.color% = float4(v_normal_view, v_depth);
//-----------------------------------------------------------------------------
	">
>

<Deferred =
	<Input =
		<Uniform=<Name="u_mv_matrix"><Semantic="ModelViewMatrix"><Scope=<Vertex>>>
		<Uniform=<Name="u_nmv_matrix"><Semantic="NormalViewMatrix"><Scope=<Fragment>>>
	>
	<Varying =
		<Variable=<Name="v_depth"><Type="float">>
	>
	<Vertex = "
//-----------------------------------------------------------------------------
v_depth = (u_mv_matrix * v_f_position).z;
float4	tmp_out_pos = u_mvp_matrix * v_f_position;

#ifdef	_USE_DEPTH_BIAS
	tmp_out_pos.z += _DEPTH_BIAS;
#endif
%out.position% = tmp_out_pos;
//-----------------------------------------------------------------------------
	">
	<Fragment = "
//-----------------------------------------------------------------------------
float3	v_normal_view = u_nmv_matrix * v_f_normal;
%out.color0% = float4(v_normal_view, v_depth);
%out.color1% = float4(%in.diffuse%.xyz, 1.0);
%out.color2% = float4(%in.specular%.xyz, %in.glossiness%);
%out.color3% = float4(%in.constant%.xyz, 0.0);
//-----------------------------------------------------------------------------
	">
>

<Forward =
	// The engine automatically declares shadow related inputs.
	<Input =
		<Uniform=<Name="u_mv_matrix"><Semantic="ModelViewMatrix"><Scope=<Vertex>>>

		// Uniform default scope is fragment.
		<Uniform=<Name="u_nmv_matrix"><Semantic="NormalViewMatrix">>

		<Uniform=<Name="u_lvp"><Semantic="LightViewPosition">>
		<Uniform=<Name="u_lvd"><Semantic="LightViewDirection">>
		<Uniform=<Name="u_lr"><Semantic="LightRange">>

		<Uniform=<Name="u_ldiff"><Semantic="LightDiffuseColor">>
		<Uniform=<Name="u_lspec"><Semantic="LightSpecularColor">>

		<Uniform=<Name="u_lcone"><Semantic="LightSpotCone">>
		<Uniform=<Name="u_ledge"><Semantic="LightSpotEdge">>

		<Uniform=<Name="u_shadow_color"><Semantic="LightShadowColor">>
	>
	<Varying =
		<Variable=<Name="v_vpos"><Type="float3">>
	>
	<Vertex = "
//-----------------------------------------------------------------------------
v_vpos = (u_mv_matrix * v_f_position).xyz;
float4 tmp_out_pos = u_mvp_matrix * v_f_position;

#ifdef	_USE_DEPTH_BIAS
	tmp_out_pos.z += _DEPTH_BIAS;
#endif
%out.position% = tmp_out_pos;
//-----------------------------------------------------------------------------
	">
	<Fragment = "
//-----------------------------------------------------------------------------
	float3	frag_viewpos = v_vpos;
	vec3	v_normal_view = u_nmv_matrix * v_f_normal;

#if		defined(_SPOT_LIGHT) || defined(_POINT_LIGHT)

	float3	light_to_fragment = v_vpos - u_lvp;
	float	light_to_fragment_d = length(light_to_fragment);

	float	k_attn = u_lr > 0.0 ? max(1.0 - light_to_fragment_d / u_lr, 0.0) : 1.0;

	light_to_fragment /= light_to_fragment_d;

#elif	defined(_LINEAR_LIGHT)

	float3	light_to_fragment = u_lvd;
	float	k_attn = 1.0;

#endif

#if		defined(_SPOT_LIGHT)

	// Cone/edge attenuation.
	float	c_attn = dot(u_lvd, light_to_fragment);
	if	(c_attn < u_lcone)
		k_attn *= c_attn < 0.0 ? 0.0 : max((c_attn - u_ledge) / (u_lcone - u_ledge), 0.0);

#endif

	// Compute Phong factors.
	float	idiff = max(-dot(light_to_fragment, v_normal_view), 0.0) * k_attn;
	float3	e = reflect(v_vpos, v_normal_view);
	float	ispec = pow(max(-dot(light_to_fragment, normalize(e)), 0.0), %in.glossiness% * 96.0) * k_attn;

	float3	_f_color = %in.diffuse%.xyz * u_ldiff * idiff + %in.specular%.xyz * u_lspec * ispec;

#ifdef	_PROJECTION_MAP
	float4	_pjm_uv = u_pjm_projection * float4(v_vpos, 1.0);
	_f_color *= texture2D(u_pjm, _pjm_uv.xy / _pjm_uv.w).rgb;
#endif

#ifdef	_CAST_SHADOW

	float	pcf = 1.0;
	#if		defined(_SPOT_LIGHT)
		pcf = ComputePCF(v_vpos, u_ssm_projection, u_ssm);
	#elif	defined(_LINEAR_LIGHT)
		%pssm_pcf_evaluation%
	#elif	defined(_POINT_LIGHT)
		%psm_pcf_evaluation%
	#endif

	_f_color = mix(u_shadow_color, _f_color, pcf);

#endif

	%out.color% = vec4(_f_color, %in.opacity%);
//-----------------------------------------------------------------------------
	">
>

<ForwardConstant =
	<Input =
		<Uniform=<Name="u_ambient"><Semantic="AmbientColor">>
	>
	<Vertex = "
//-----------------------------------------------------------------------------
float4	tmp_out_pos = u_mvp_matrix * v_f_position;

#ifdef	_USE_DEPTH_BIAS
tmp_out_pos.z += _DEPTH_BIAS;
#endif
%out.position% = tmp_out_pos;
//-----------------------------------------------------------------------------
	">
	<Fragment = "
//-----------------------------------------------------------------------------
%out.color% = float4(%in.diffuse%.xyz * u_ambient + %in.constant%.xyz, %in.opacity%);
//-----------------------------------------------------------------------------
	">
>